#+STARTUP: showall indent hidestars
#+TOC: headlines 3

* Избежать malloc/free в каждой рамке

Сейчас мы каждый раз аллоцируем и очищаем большой массив гистограмм, маски и т. д. Это дорого:
- Перенести буферы гистограмм (hist) и битовых масок в GlobalContext или в сами FrameSlot, выделив их один раз при старте.
- Тогда в quantize_and_analyze просто memset этих буферов, а не кучу раз malloc/free.

* Улучшить локальность при построении маски

Сейчас мы после квантования снова проходим по блокам и читаем из slot->quant хаотично. Можно строить маску прямо на первом проходе (либо на втором, но по упорядоченному адресу), чтобы не дергать память «туда-сюда».

* Пул объектов для регионов и очереди BFS

Нелинейное выделение (realloc пикселей региона, malloc/free для queue и visited) тормозит и фрагментирует кучу. Завести статические или заранее выровненные пулы в GlobalContext или локально в потоке:

#+BEGIN_SRC c
  static Pixel queue[MAX_PIXELS];
  static bool visited[MAX_PIXELS];
#+END_SRC

Или хотя бы posix_memalign их один раз.

* Алгоритмическая оптимизация детекции регионов

Сейчас для каждого пикселя мы обходим BFS, потом сортируем регионы, потом кликаем по каждой паре для поиска «соседей» — O(N²).

- Можно свести set_region_neighbors к линейному обходу после сортировки по minx, или хранить для каждого ряда карту по Y, чтобы не проверять все регионы.
- Группировку в строки (group_regions) можно делать одновременно с детекцией, если вести очереди по miny.

* Предварительная компиляция под несколько ISA

Вместо -msse4.1 -mavx2 одной универсальной сборки можно сделать две: одну с AVX2 для новых CPU, другую с SSE2 для совместимости, и на старте runtime выбирать оптимальную.

* Уменьшить синхронизацию между потоками

Сейчас capture / worker / serializer конкурируют по кольцу слотов, отчасти активно «spin-waiting».

- Перейти на условные переменные или sem_post/sem_wait для уведомления о готовности, чтобы не тратить CPU на sched_yield().
- Можно сделать отдельный lock-free очередь слотов RAW_READY → IN_PROGRESS → QUANT_DONE, а не три петли по всем слотам.

Inline / prefetch / branchless

- Заменить скалярный код внутри for на максимально «branchless» (через маску (v == base) и &), чтобы избавить ветвления.
- Повесить _mm_prefetch на следующие строки из rgba, если память — узкое место.
- Пометить часто вызываемые мелкие функции (popcount8, render_region) как __attribute__((always_inline)).

* Профилирование и сбор счётчиков

Простой clock_gettime вокруг каждого этапа покажет, где уходит время. Можете собрать статистику по времени квантования, детекции и сериализации, чтобы приоритетно оптимизировать самое дорогое.

* Параллельное квантование

Если много слотов, можно разбить изображение не по слотам, а по горизонтальным полосам, и дать каждому worker’у обрабатывать свою полосу внутри одного кадра. Тогда весь конвейер займёт все ядра и не будет простаивать на slots=1.

Упаковка маски

Сейчас у нас (BS*BS+7)/8 байт, но можно хранить разреженно (например, run-length), если блоки почти uniform, и тратить меньше памяти и времени на очистку больших zero-масок.
